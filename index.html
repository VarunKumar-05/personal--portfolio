<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio — Domain Expansion</title>
    <meta name="description" content="Personal portfolio — Enter the Infinite Void.">
    <link rel="stylesheet" href="styles.css">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <!-- Film Grain -->
    <div id="grain"></div>

    <!-- =============================================
         PRE-INTRO: Hand Gesture Splash
         ============================================= -->
    <div id="gesture-splash">
        <img src="handgesture.jpeg" alt="Domain Expansion Gesture">
    </div>

    <!-- =============================================
         PHASE 1: Domain Expansion Intro
         ============================================= -->
    <div id="intro-overlay">
        <div class="intro-title-group">
            <div class="intro-title">INFINITE VOID</div>
            <div class="intro-kanji">無量空処</div>
        </div>


        <div class="enter-cta" id="enter-btn">
            <div class="enter-cta-text">Enter</div>
            <div class="enter-cta-line"></div>
        </div>
    </div>

    <!-- =============================================
         PHASE 2: Portfolio Content
         ============================================= -->
    <div id="portfolio-content">
        <!-- Video Background -->
        <div class="video-bg-container">
            <video autoplay muted loop playsinline>
                <source src="background-motion.mp4" type="video/mp4">
            </video>
            <div class="video-bg-overlay"></div>
        </div>

        <!-- Hero -->
        <section class="hero-section">
            <h1 class="hero-name">YOUR NAME</h1>
            <p class="hero-tagline">Developer · Designer · Creator</p>
            <div class="hero-divider"></div>
            <p class="hero-description">
                Welcome to my domain. I build immersive digital experiences
                that push the boundaries of what's possible on the web.
            </p>
        </section>

        <!-- Projects -->
        <section class="portfolio-section">
            <div class="section-header">
                <div class="section-label">Selected Works</div>
                <h2 class="section-title">Projects</h2>
            </div>
            <div class="card-grid">
                <div class="glass-card">
                    <div class="card-title">Project Alpha</div>
                    <div class="card-description">
                        A cutting-edge web application showcasing modern design patterns
                        and real-time data visualization capabilities.
                    </div>
                    <div class="card-tags">
                        <span class="card-tag">React</span>
                        <span class="card-tag">Three.js</span>
                        <span class="card-tag">WebGL</span>
                    </div>
                </div>
                <div class="glass-card">
                    <div class="card-title">Project Beta</div>
                    <div class="card-description">
                        Full-stack platform with real-time messaging, event management,
                        and a lightweight, responsive frontend architecture.
                    </div>
                    <div class="card-tags">
                        <span class="card-tag">Node.js</span>
                        <span class="card-tag">WebSocket</span>
                        <span class="card-tag">PostgreSQL</span>
                    </div>
                </div>
                <div class="glass-card">
                    <div class="card-title">Project Gamma</div>
                    <div class="card-description">
                        Machine learning pipeline for predictive analysis with
                        real-time data streaming and interactive dashboard.
                    </div>
                    <div class="card-tags">
                        <span class="card-tag">Python</span>
                        <span class="card-tag">TensorFlow</span>
                        <span class="card-tag">Kafka</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- About -->
        <section class="portfolio-section">
            <div class="section-header">
                <div class="section-label">Background</div>
                <h2 class="section-title">About</h2>
            </div>
            <div class="glass-card" style="max-width: 700px; margin: 0 auto;">
                <div class="card-description" style="text-align: center;">
                    I'm a developer passionate about building beautiful, performant applications
                    that solve real problems. With experience across the full stack, I bring ideas
                    to life from concept to deployment. When I'm not coding, I'm exploring new
                    technologies and pushing creative boundaries.
                </div>
            </div>
        </section>

        <!-- Contact -->
        <section class="contact-section">
            <div class="section-header">
                <div class="section-label">Connect</div>
                <h2 class="section-title">Get In Touch</h2>
            </div>
            <div class="contact-links">
                <a href="#" class="contact-link">GitHub</a>
                <a href="#" class="contact-link">LinkedIn</a>
                <a href="#" class="contact-link">Email</a>
            </div>
            <div class="footer-text">© 2026 — Built with cursed energy</div>
        </section>
    </div>

    <!-- =============================================
         THREE.JS — Infinite Void Radial Streaks
         ============================================= -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ─── Gesture Splash — fade out after 200ms ──
        const gestureSplash = document.getElementById('gesture-splash');
        setTimeout(() => {
            gestureSplash.classList.add('fade-out');
            setTimeout(() => gestureSplash.style.display = 'none', 500);
        }, 400);

        // ─── Scene Setup ────────────────────────────
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 70;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.domElement.id = 'three-canvas';
        document.body.prepend(renderer.domElement);

        // ─── Post-Processing (Bloom) ────────────────
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.2,   // strength (slightly higher for line glow)
            0.6,   // radius
            0.75   // threshold
        );
        composer.addPass(bloomPass);

        // ─── Multi-Color Palette ────────────────────
        const PALETTE = [
            { r: 0.0, g: 0.90, b: 1.0 },  // Cyan
            { r: 0.49, g: 0.30, b: 1.0 },  // Purple
            { r: 1.0, g: 0.20, b: 0.60 },  // Magenta / Hot Pink
            { r: 1.0, g: 0.78, b: 0.10 },  // Gold
            { r: 0.0, g: 1.0, b: 0.70 },  // Teal / Mint
            { r: 1.0, g: 0.45, b: 0.30 },  // Coral / Orange
            { r: 0.55, g: 0.80, b: 1.0 },  // Ice Blue
            { r: 0.85, g: 0.15, b: 1.0 },  // Electric Violet
        ];

        // ─── Radial Streak System ───────────────────
        // Each streak = one line segment (2 vertices * 3 coords)
        const STREAK_COUNT = 1200;
        const VERTEX_COUNT = STREAK_COUNT * 2;  // 2 endpoints per line

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(VERTEX_COUNT * 3);
        const colors = new Float32Array(VERTEX_COUNT * 3);

        const targetPositions = new Float32Array(VERTEX_COUNT * 3);
        const targetColors = new Float32Array(VERTEX_COUNT * 3);

        // Per-streak metadata: angle, speed, base length, color index
        const streakMeta = [];

        // Initialize streaks — start as invisible dots at center
        for (let i = 0; i < STREAK_COUNT; i++) {
            const v0 = i * 2;      // inner vertex index
            const v1 = i * 2 + 1;  // outer vertex index

            // Random direction in 3D (spherical coords)
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const dx = Math.sin(phi) * Math.cos(theta);
            const dy = Math.sin(phi) * Math.sin(theta);
            const dz = Math.cos(phi);

            // Start all at origin (invisible)
            for (let c = 0; c < 3; c++) {
                positions[v0 * 3 + c] = 0;
                positions[v1 * 3 + c] = 0;
                colors[v0 * 3 + c] = 0;
                colors[v1 * 3 + c] = 0;
            }

            const colorIdx = Math.floor(Math.random() * PALETTE.length);
            const baseLen = 3 + Math.random() * 12;
            const innerR = 2 + Math.random() * 8;
            const speed = 0.5 + Math.random() * 1.5;

            streakMeta.push({ dx, dy, dz, theta, phi, colorIdx, baseLen, innerR, speed, phase: Math.random() * Math.PI * 2 });
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const streakMaterial = new THREE.LineBasicMaterial({
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            linewidth: 1  // WebGL always renders 1px, bloom makes them glow wider
        });

        const streaks = new THREE.LineSegments(geometry, streakMaterial);
        scene.add(streaks);

        // ─── Convergence Center (shifted left) ──────
        const CENTER_X = -25;  // offset to the left in world units

        // ─── Void Formation Targets ─────────────────
        function setVoidTargets() {
            for (let i = 0; i < STREAK_COUNT; i++) {
                const m = streakMeta[i];
                const v0 = i * 2;
                const v1 = i * 2 + 1;
                const pal = PALETTE[m.colorIdx];

                // Layer distribution for the void structure
                let innerR, outerR, brightMul;
                const t = i / STREAK_COUNT;

                if (t < 0.15) {
                    // Event horizon ring — tight ring at radius ~24-28
                    const ringAngle = Math.random() * Math.PI * 2;
                    const rx = Math.cos(ringAngle);
                    const ry = Math.sin(ringAngle);
                    const rz = (Math.random() - 0.5) * 0.15;
                    const rInner = 22 + Math.random() * 3;
                    const rOuter = rInner + 2 + Math.random() * 3;
                    targetPositions[v0 * 3] = CENTER_X + rx * rInner;
                    targetPositions[v0 * 3 + 1] = ry * rInner;
                    targetPositions[v0 * 3 + 2] = rz * rInner;
                    targetPositions[v1 * 3] = CENTER_X + rx * rOuter;
                    targetPositions[v1 * 3 + 1] = ry * rOuter;
                    targetPositions[v1 * 3 + 2] = rz * rOuter;
                    // White-ish bright streaks
                    targetColors[v0 * 3] = 1.0; targetColors[v0 * 3 + 1] = 1.0; targetColors[v0 * 3 + 2] = 1.0;
                    targetColors[v1 * 3] = pal.r * 0.6; targetColors[v1 * 3 + 1] = pal.g * 0.6; targetColors[v1 * 3 + 2] = pal.b * 0.6;
                } else if (t < 0.35) {
                    // Inner radial burst — short streaks radiating from center
                    innerR = 1 + Math.random() * 4;
                    outerR = innerR + m.baseLen * 0.6;
                    targetPositions[v0 * 3] = CENTER_X + m.dx * innerR;
                    targetPositions[v0 * 3 + 1] = m.dy * innerR;
                    targetPositions[v0 * 3 + 2] = m.dz * innerR;
                    targetPositions[v1 * 3] = CENTER_X + m.dx * outerR;
                    targetPositions[v1 * 3 + 1] = m.dy * outerR;
                    targetPositions[v1 * 3 + 2] = m.dz * outerR;
                    // Bright inner → color outer
                    targetColors[v0 * 3] = 1.0; targetColors[v0 * 3 + 1] = 1.0; targetColors[v0 * 3 + 2] = 1.0;
                    targetColors[v1 * 3] = pal.r; targetColors[v1 * 3 + 1] = pal.g; targetColors[v1 * 3 + 2] = pal.b;
                } else if (t < 0.65) {
                    // Mid-range radial streaks
                    innerR = 8 + Math.random() * 12;
                    outerR = innerR + m.baseLen;
                    targetPositions[v0 * 3] = CENTER_X + m.dx * innerR;
                    targetPositions[v0 * 3 + 1] = m.dy * innerR;
                    targetPositions[v0 * 3 + 2] = m.dz * innerR;
                    targetPositions[v1 * 3] = CENTER_X + m.dx * outerR;
                    targetPositions[v1 * 3 + 1] = m.dy * outerR;
                    targetPositions[v1 * 3 + 2] = m.dz * outerR;
                    brightMul = 0.7 + Math.random() * 0.3;
                    targetColors[v0 * 3] = pal.r * brightMul; targetColors[v0 * 3 + 1] = pal.g * brightMul; targetColors[v0 * 3 + 2] = pal.b * brightMul;
                    targetColors[v1 * 3] = pal.r * 0.15; targetColors[v1 * 3 + 1] = pal.g * 0.15; targetColors[v1 * 3 + 2] = pal.b * 0.15;
                } else {
                    // Outer cosmos streaks — long, faint
                    innerR = 25 + Math.random() * 40;
                    outerR = innerR + m.baseLen * 1.5 + Math.random() * 8;
                    targetPositions[v0 * 3] = CENTER_X + m.dx * innerR;
                    targetPositions[v0 * 3 + 1] = m.dy * innerR;
                    targetPositions[v0 * 3 + 2] = m.dz * innerR;
                    targetPositions[v1 * 3] = CENTER_X + m.dx * outerR;
                    targetPositions[v1 * 3 + 1] = m.dy * outerR;
                    targetPositions[v1 * 3 + 2] = m.dz * outerR;
                    brightMul = 0.3 + Math.random() * 0.4;
                    targetColors[v0 * 3] = pal.r * brightMul; targetColors[v0 * 3 + 1] = pal.g * brightMul; targetColors[v0 * 3 + 2] = pal.b * brightMul;
                    targetColors[v1 * 3] = 0; targetColors[v1 * 3 + 1] = 0; targetColors[v1 * 3 + 2] = 0;
                }
            }
        }

        // ─── Dissolve Targets ───────────────────────
        function setDissolveTargets() {
            for (let i = 0; i < STREAK_COUNT; i++) {
                const m = streakMeta[i];
                const v0 = i * 2;
                const v1 = i * 2 + 1;
                const r = 100 + Math.random() * 200;
                // Shoot outward along same direction
                targetPositions[v0 * 3] = CENTER_X + m.dx * r;
                targetPositions[v0 * 3 + 1] = m.dy * r;
                targetPositions[v0 * 3 + 2] = m.dz * r;
                targetPositions[v1 * 3] = CENTER_X + m.dx * (r + 2);
                targetPositions[v1 * 3 + 1] = m.dy * (r + 2);
                targetPositions[v1 * 3 + 2] = m.dz * (r + 2);
                for (let c = 0; c < 3; c++) {
                    targetColors[v0 * 3 + c] = 0;
                    targetColors[v1 * 3 + c] = 0;
                }
            }
        }

        // ─── Animation State ────────────────────────
        let phase = 'intro';
        let animationTime = 0;
        let formationProgress = 0;
        let cameraTargetZ = 55;
        let bloomTarget = 2.2;

        // Start the void formation after a brief delay
        setTimeout(() => {
            phase = 'void-forming';
            setVoidTargets();
        }, 800);

        // ─── Enter Button Handler ───────────────────
        const enterBtn = document.getElementById('enter-btn');
        const introOverlay = document.getElementById('intro-overlay');
        const portfolioContent = document.getElementById('portfolio-content');

        enterBtn.addEventListener('click', () => {
            if (phase === 'void-forming' || phase === 'void-active') {
                phase = 'dissolve';
                bloomTarget = 0.5;
                cameraTargetZ = 30;
                setDissolveTargets();
                introOverlay.classList.add('hidden');

                setTimeout(() => {
                    portfolioContent.classList.add('visible');
                    document.body.classList.add('scrollable');
                    renderer.domElement.style.transition = 'opacity 2s ease';
                    renderer.domElement.style.opacity = '0';
                    setTimeout(() => {
                        phase = 'portfolio';
                        renderer.domElement.style.display = 'none';
                    }, 2000);
                }, 1500);
            }
        });

        // ─── Animation Loop ────────────────────────
        function animate() {
            requestAnimationFrame(animate);
            if (phase === 'portfolio') return;

            animationTime += 0.016;

            const pos = streaks.geometry.attributes.position.array;
            const col = streaks.geometry.attributes.color.array;

            const lerpSpeed = phase === 'dissolve' ? 0.025 : 0.05;

            // Interpolate all vertex positions and colors toward targets
            for (let i = 0; i < VERTEX_COUNT * 3; i++) {
                pos[i] += (targetPositions[i] - pos[i]) * lerpSpeed;
                col[i] += (targetColors[i] - col[i]) * lerpSpeed;
            }

            // Linear inward flow — streaks converge toward center
            if (phase === 'void-forming' || phase === 'void-active') {
                for (let i = 0; i < STREAK_COUNT; i++) {
                    const m = streakMeta[i];
                    const v0 = i * 2;
                    const v1 = i * 2 + 1;
                    const pal = PALETTE[m.colorIdx];

                    const inwardSpeed = m.speed * 0.15;

                    // Move both vertices inward along their radial direction
                    pos[v0 * 3] -= m.dx * inwardSpeed;
                    pos[v0 * 3 + 1] -= m.dy * inwardSpeed;
                    pos[v0 * 3 + 2] -= m.dz * inwardSpeed;
                    pos[v1 * 3] -= m.dx * inwardSpeed;
                    pos[v1 * 3 + 1] -= m.dy * inwardSpeed;
                    pos[v1 * 3 + 2] -= m.dz * inwardSpeed;

                    // Check if inner vertex has reached near the center — respawn at outer edge
                    const dx = pos[v0 * 3] - CENTER_X;
                    const dy = pos[v0 * 3 + 1];
                    const dz = pos[v0 * 3 + 2];
                    const distToCenter = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (distToCenter < 3) {
                        // Respawn at outer edge
                        const spawnR = 35 + Math.random() * 40;
                        const streakLen = m.baseLen + Math.random() * 5;
                        pos[v0 * 3] = CENTER_X + m.dx * (spawnR + streakLen);
                        pos[v0 * 3 + 1] = m.dy * (spawnR + streakLen);
                        pos[v0 * 3 + 2] = m.dz * (spawnR + streakLen);
                        pos[v1 * 3] = CENTER_X + m.dx * spawnR;
                        pos[v1 * 3 + 1] = m.dy * spawnR;
                        pos[v1 * 3 + 2] = m.dz * spawnR;

                        // Refresh color with full brightness
                        col[v1 * 3] = pal.r;
                        col[v1 * 3 + 1] = pal.g;
                        col[v1 * 3 + 2] = pal.b;
                        col[v0 * 3] = pal.r * 0.2;
                        col[v0 * 3 + 1] = pal.g * 0.2;
                        col[v0 * 3 + 2] = pal.b * 0.2;
                    }

                    // Brighten streaks as they approach center (white-hot near convergence)
                    if (distToCenter < 15) {
                        const whiteness = 1 - (distToCenter / 15);
                        col[v0 * 3] += (1.0 - col[v0 * 3]) * whiteness * 0.1;
                        col[v0 * 3 + 1] += (1.0 - col[v0 * 3 + 1]) * whiteness * 0.1;
                        col[v0 * 3 + 2] += (1.0 - col[v0 * 3 + 2]) * whiteness * 0.1;
                    }
                }
            }

            streaks.geometry.attributes.position.needsUpdate = true;
            streaks.geometry.attributes.color.needsUpdate = true;

            // Smooth right-to-left horizontal drift (no rotation)
            if (phase !== 'dissolve') {
                streaks.position.x = Math.sin(animationTime * 0.12) * 10 - 5;
            }

            // Camera tracks the offset center point
            camera.position.z += (cameraTargetZ - camera.position.z) * 0.01;
            camera.position.x = CENTER_X * 0.3 + Math.sin(animationTime * 0.15) * 2;
            camera.position.y = Math.cos(animationTime * 0.1) * 1.5;
            camera.lookAt(CENTER_X * 0.5, 0, 0);

            // Bloom intensity
            bloomPass.strength += (bloomTarget - bloomPass.strength) * 0.02;

            // Slight screen shake during formation
            if (phase === 'void-forming') {
                formationProgress += 0.005;
                if (formationProgress > 1) {
                    phase = 'void-active';
                }
                const shake = Math.max(0, 0.3 - formationProgress * 0.3);
                renderer.domElement.style.transform = `translate(${(Math.random() - 0.5) * shake * 20}px, ${(Math.random() - 0.5) * shake * 20}px)`;
            } else {
                renderer.domElement.style.transform = 'translate(0,0)';
            }

            composer.render();
        }
        animate();

        // ─── Resize Handler ─────────────────────────
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>