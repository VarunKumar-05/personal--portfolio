<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio â€” Domain Expansion</title>
    <meta name="description" content="Personal portfolio â€” Enter the Infinite Void.">
    <link rel="stylesheet" href="styles.css">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <!-- Film Grain -->
    <div id="grain"></div>

    <!-- =============================================
         PRE-INTRO: Hand Gesture Splash
         ============================================= -->
    <div id="gesture-splash">
        <div class="gesture-container">
            <img src="handgesture.jpeg" alt="Domain Expansion Gesture">
            <div class="gesture-text">DOMAIN EXPANSION</div>
        </div>
    </div>

    <!-- =============================================
         PHASE 1: Domain Expansion Intro
         ============================================= -->
    <div id="intro-overlay">
        <div class="intro-title-group">
            <div class="intro-title">INFINITE VOID</div>
            <div class="intro-kanji">ç„¡é‡ç©ºå‡¦</div>
        </div>


        <div class="enter-cta" id="enter-btn">
            <div class="enter-cta-text">Enter</div>
            <div class="enter-cta-line"></div>
        </div>
    </div>

    <!-- =============================================
         PHASE 2: Portfolio Content
         ============================================= -->
    <div id="portfolio-content">

        <!-- Hero Section -->
        <section class="hero-section">
            <div class="hero-badge">III Year â€” Undergrad</div>
            <h1 class="hero-name">VARUN KUMAR</h1>
            <p class="hero-tagline">Artificial Intelligence Â· Deep Learning Â· Agentic Systems</p>
            <div class="hero-divider"></div>
            <p class="hero-description">
                Building intelligent systems that think, learn, and adapt.
                From multi-agent architectures to deep learning pipelines â€”
                I engineer the future of AI, one model at a time.
            </p>
            <div class="hero-social-links">
                <a href="https://github.com/VarunKumar-05" target="_blank" class="social-icon-link" title="GitHub">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z" />
                    </svg>
                </a>
                <a href="https://www.linkedin.com/in/varun-kumar-balasubramanian/" target="_blank"
                    class="social-icon-link" title="LinkedIn">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z" />
                    </svg>
                </a>
                <a href="https://leetcode.com/u/varunkumarBalasubramanian/" target="_blank" class="social-icon-link"
                    title="LeetCode">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M13.483 0a1.374 1.374 0 0 0-.961.438L7.116 6.226l-3.854 4.126a5.266 5.266 0 0 0-1.209 2.104 5.35 5.35 0 0 0-.125.513 5.527 5.527 0 0 0 .062 2.362 5.83 5.83 0 0 0 .349 1.017 5.938 5.938 0 0 0 1.271 1.818l4.277 4.193.039.038c2.248 2.165 5.852 2.133 8.063-.074l2.396-2.392c.54-.54.54-1.414.003-1.955a1.378 1.378 0 0 0-1.951-.003l-2.396 2.392a3.021 3.021 0 0 1-4.205.038l-.02-.019-4.276-4.193c-.652-.64-.972-1.469-.948-2.263a2.68 2.68 0 0 1 .066-.523 2.545 2.545 0 0 1 .619-1.164L9.13 8.114c1.058-1.134 3.204-1.27 4.43-.278l3.501 2.831c.593.48 1.461.387 1.94-.207a1.384 1.384 0 0 0-.207-1.943l-3.5-2.831c-.8-.647-1.766-1.045-2.774-1.202l2.015-2.158A1.384 1.384 0 0 0 13.483 0zm-2.866 12.815a1.38 1.38 0 0 0-1.38 1.382 1.38 1.38 0 0 0 1.38 1.382H20.79a1.38 1.38 0 0 0 1.38-1.382 1.38 1.38 0 0 0-1.38-1.382z" />
                    </svg>
                </a>
                <a href="https://codeforces.com/profile/Varunkumar-01" target="_blank" class="social-icon-link"
                    title="Codeforces">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M4.5 7.5C5.328 7.5 6 8.172 6 9v10.5c0 .828-.672 1.5-1.5 1.5h-3C.672 21 0 20.328 0 19.5V9c0-.828.672-1.5 1.5-1.5h3zm9-4.5c.828 0 1.5.672 1.5 1.5v15c0 .828-.672 1.5-1.5 1.5h-3c-.828 0-1.5-.672-1.5-1.5v-15c0-.828.672-1.5 1.5-1.5h3zm9 7.5c.828 0 1.5.672 1.5 1.5v7.5c0 .828-.672 1.5-1.5 1.5h-3c-.828 0-1.5-.672-1.5-1.5V12c0-.828.672-1.5 1.5-1.5h3z" />
                    </svg>
                </a>
            </div>
        </section>

        <!-- Skills Section -->
        <section class="portfolio-section">
            <div class="section-header">
                <div class="section-label">Expertise</div>
                <h2 class="section-title">Skills & Technologies</h2>
            </div>
            <div class="skills-grid">
                <div class="skill-category">
                    <div class="skill-category-title">
                        <span class="skill-icon">âš¡</span> Languages & Tools
                    </div>
                    <div class="skill-tags">
                        <span class="skill-tag">Python</span>
                        <span class="skill-tag">Java</span>
                        <span class="skill-tag">SQL</span>
                        <span class="skill-tag">MongoDB</span>
                        <span class="skill-tag">Docker</span>
                        <span class="skill-tag">Git</span>
                    </div>
                </div>
                <div class="skill-category">
                    <div class="skill-category-title">
                        <span class="skill-icon">ğŸ§ </span> AI & Machine Learning
                    </div>
                    <div class="skill-tags">
                        <span class="skill-tag tag-ai">Machine Learning</span>
                        <span class="skill-tag tag-ai">Deep Learning</span>
                        <span class="skill-tag tag-ai">RAG</span>
                        <span class="skill-tag tag-ai">Agentic AI</span>
                        <span class="skill-tag tag-ai">Multi-Agents</span>
                        <span class="skill-tag tag-ai">Google Multi-Agent Modules</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Achievements Section -->
        <section class="portfolio-section">
            <div class="section-header">
                <div class="section-label">Recognition</div>
                <h2 class="section-title">Achievements</h2>
            </div>
            <div class="achievements-list">
                <div class="achievement-card">
                    <div class="achievement-icon">ğŸ†</div>
                    <div class="achievement-content">
                        <div class="achievement-title">Synaptix AI Hackathon â€” IIT Madras</div>
                        <div class="achievement-badge">Finalist</div>
                    </div>
                </div>
                <div class="achievement-card">
                    <div class="achievement-icon">ğŸ’»</div>
                    <div class="achievement-content">
                        <div class="achievement-title">Competitive Programming â€” IIT Madras</div>
                        <div class="achievement-badge">Finalist</div>
                    </div>
                </div>
                <div class="achievement-card">
                    <div class="achievement-icon">ğŸš€</div>
                    <div class="achievement-content">
                        <div class="achievement-title">TATA Imagination Challenge</div>
                        <div class="achievement-badge">Semi-Finalist</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Contact Section -->
        <section class="contact-section">
            <div class="section-header">
                <div class="section-label">Connect</div>
                <h2 class="section-title">Get In Touch</h2>
            </div>
            <div class="contact-links">
                <a href="https://github.com/VarunKumar-05" target="_blank" class="contact-link">GitHub</a>
                <a href="https://www.linkedin.com/in/varun-kumar-balasubramanian/" target="_blank"
                    class="contact-link">LinkedIn</a>
                <a href="https://leetcode.com/u/varunkumarBalasubramanian/" target="_blank"
                    class="contact-link">LeetCode</a>
                <a href="https://codeforces.com/profile/Varunkumar-01" target="_blank"
                    class="contact-link">Codeforces</a>
            </div>
            <div class="footer-text">Â© 2026 Varun Kumar â€” Built with cursed energy</div>
        </section>
    </div>


    <!-- =============================================
         THREE.JS â€” Infinite Void Radial Streaks
         ============================================= -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // â”€â”€â”€ Gesture Splash â€” fade out after 200ms â”€â”€
        const gestureSplash = document.getElementById('gesture-splash');
        setTimeout(() => {
            gestureSplash.classList.add('fade-out');
            setTimeout(() => gestureSplash.style.display = 'none', 500);
        }, 500);

        // â”€â”€â”€ Scene Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 70;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.domElement.id = 'three-canvas';
        document.body.prepend(renderer.domElement);

        // â”€â”€â”€ Post-Processing (Bloom) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.2,   // strength (slightly higher for line glow)
            0.6,   // radius
            0.75   // threshold
        );
        composer.addPass(bloomPass);

        // â”€â”€â”€ Multi-Color Palette â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const PALETTE = [
            { r: 0.0, g: 0.90, b: 1.0 },  // Cyan
            { r: 0.49, g: 0.30, b: 1.0 },  // Purple
            { r: 1.0, g: 0.20, b: 0.60 },  // Magenta / Hot Pink
            { r: 1.0, g: 0.78, b: 0.10 },  // Gold
            { r: 0.0, g: 1.0, b: 0.70 },  // Teal / Mint
            { r: 1.0, g: 0.45, b: 0.30 },  // Coral / Orange
            { r: 0.55, g: 0.80, b: 1.0 },  // Ice Blue
            { r: 0.85, g: 0.15, b: 1.0 },  // Electric Violet
        ];

        // â”€â”€â”€ Radial Streak System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Each streak = one line segment (2 vertices * 3 coords)
        const STREAK_COUNT = 1200;
        const VERTEX_COUNT = STREAK_COUNT * 2;  // 2 endpoints per line

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(VERTEX_COUNT * 3);
        const colors = new Float32Array(VERTEX_COUNT * 3);

        const targetPositions = new Float32Array(VERTEX_COUNT * 3);
        const targetColors = new Float32Array(VERTEX_COUNT * 3);

        // Per-streak metadata: angle, speed, base length, color index
        const streakMeta = [];

        // Initialize streaks â€” start as invisible dots at center
        for (let i = 0; i < STREAK_COUNT; i++) {
            const v0 = i * 2;      // inner vertex index
            const v1 = i * 2 + 1;  // outer vertex index

            // Random direction in 3D (spherical coords)
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const dx = Math.sin(phi) * Math.cos(theta);
            const dy = Math.sin(phi) * Math.sin(theta);
            const dz = Math.cos(phi);

            // Start all at origin (invisible)
            for (let c = 0; c < 3; c++) {
                positions[v0 * 3 + c] = 0;
                positions[v1 * 3 + c] = 0;
                colors[v0 * 3 + c] = 0;
                colors[v1 * 3 + c] = 0;
            }

            const colorIdx = Math.floor(Math.random() * PALETTE.length);
            const baseLen = 3 + Math.random() * 12;
            const innerR = 2 + Math.random() * 8;
            const speed = 0.5 + Math.random() * 1.5;

            streakMeta.push({ dx, dy, dz, theta, phi, colorIdx, baseLen, innerR, speed, phase: Math.random() * Math.PI * 2 });
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const streakMaterial = new THREE.LineBasicMaterial({
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            linewidth: 1  // WebGL always renders 1px, bloom makes them glow wider
        });

        const streaks = new THREE.LineSegments(geometry, streakMaterial);
        scene.add(streaks);

        // â”€â”€â”€ Convergence Center (shifted left) â”€â”€â”€â”€â”€â”€
        const CENTER_X = -25;  // offset to the left in world units

        // â”€â”€â”€ Void Formation Targets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function setVoidTargets() {
            for (let i = 0; i < STREAK_COUNT; i++) {
                const m = streakMeta[i];
                const v0 = i * 2;
                const v1 = i * 2 + 1;
                const pal = PALETTE[m.colorIdx];

                // Layer distribution for the void structure
                let innerR, outerR, brightMul;
                const t = i / STREAK_COUNT;

                if (t < 0.15) {
                    // Event horizon ring â€” tight ring at radius ~24-28
                    const ringAngle = Math.random() * Math.PI * 2;
                    const rx = Math.cos(ringAngle);
                    const ry = Math.sin(ringAngle);
                    const rz = (Math.random() - 0.5) * 0.15;
                    const rInner = 22 + Math.random() * 3;
                    const rOuter = rInner + 2 + Math.random() * 3;
                    targetPositions[v0 * 3] = CENTER_X + rx * rInner;
                    targetPositions[v0 * 3 + 1] = ry * rInner;
                    targetPositions[v0 * 3 + 2] = rz * rInner;
                    targetPositions[v1 * 3] = CENTER_X + rx * rOuter;
                    targetPositions[v1 * 3 + 1] = ry * rOuter;
                    targetPositions[v1 * 3 + 2] = rz * rOuter;
                    // White-ish bright streaks
                    targetColors[v0 * 3] = 1.0; targetColors[v0 * 3 + 1] = 1.0; targetColors[v0 * 3 + 2] = 1.0;
                    targetColors[v1 * 3] = pal.r * 0.6; targetColors[v1 * 3 + 1] = pal.g * 0.6; targetColors[v1 * 3 + 2] = pal.b * 0.6;
                } else if (t < 0.35) {
                    // Inner radial burst â€” short streaks radiating from center
                    innerR = 1 + Math.random() * 4;
                    outerR = innerR + m.baseLen * 0.6;
                    targetPositions[v0 * 3] = CENTER_X + m.dx * innerR;
                    targetPositions[v0 * 3 + 1] = m.dy * innerR;
                    targetPositions[v0 * 3 + 2] = m.dz * innerR;
                    targetPositions[v1 * 3] = CENTER_X + m.dx * outerR;
                    targetPositions[v1 * 3 + 1] = m.dy * outerR;
                    targetPositions[v1 * 3 + 2] = m.dz * outerR;
                    // Bright inner â†’ color outer
                    targetColors[v0 * 3] = 1.0; targetColors[v0 * 3 + 1] = 1.0; targetColors[v0 * 3 + 2] = 1.0;
                    targetColors[v1 * 3] = pal.r; targetColors[v1 * 3 + 1] = pal.g; targetColors[v1 * 3 + 2] = pal.b;
                } else if (t < 0.65) {
                    // Mid-range radial streaks
                    innerR = 8 + Math.random() * 12;
                    outerR = innerR + m.baseLen;
                    targetPositions[v0 * 3] = CENTER_X + m.dx * innerR;
                    targetPositions[v0 * 3 + 1] = m.dy * innerR;
                    targetPositions[v0 * 3 + 2] = m.dz * innerR;
                    targetPositions[v1 * 3] = CENTER_X + m.dx * outerR;
                    targetPositions[v1 * 3 + 1] = m.dy * outerR;
                    targetPositions[v1 * 3 + 2] = m.dz * outerR;
                    brightMul = 0.7 + Math.random() * 0.3;
                    targetColors[v0 * 3] = pal.r * brightMul; targetColors[v0 * 3 + 1] = pal.g * brightMul; targetColors[v0 * 3 + 2] = pal.b * brightMul;
                    targetColors[v1 * 3] = pal.r * 0.15; targetColors[v1 * 3 + 1] = pal.g * 0.15; targetColors[v1 * 3 + 2] = pal.b * 0.15;
                } else {
                    // Outer cosmos streaks â€” long, faint
                    innerR = 25 + Math.random() * 40;
                    outerR = innerR + m.baseLen * 1.5 + Math.random() * 8;
                    targetPositions[v0 * 3] = CENTER_X + m.dx * innerR;
                    targetPositions[v0 * 3 + 1] = m.dy * innerR;
                    targetPositions[v0 * 3 + 2] = m.dz * innerR;
                    targetPositions[v1 * 3] = CENTER_X + m.dx * outerR;
                    targetPositions[v1 * 3 + 1] = m.dy * outerR;
                    targetPositions[v1 * 3 + 2] = m.dz * outerR;
                    brightMul = 0.3 + Math.random() * 0.4;
                    targetColors[v0 * 3] = pal.r * brightMul; targetColors[v0 * 3 + 1] = pal.g * brightMul; targetColors[v0 * 3 + 2] = pal.b * brightMul;
                    targetColors[v1 * 3] = 0; targetColors[v1 * 3 + 1] = 0; targetColors[v1 * 3 + 2] = 0;
                }
            }
        }

        // â”€â”€â”€ Dissolve Targets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function setDissolveTargets() {
            for (let i = 0; i < STREAK_COUNT; i++) {
                const m = streakMeta[i];
                const v0 = i * 2;
                const v1 = i * 2 + 1;
                const r = 100 + Math.random() * 200;
                // Shoot outward along same direction
                targetPositions[v0 * 3] = CENTER_X + m.dx * r;
                targetPositions[v0 * 3 + 1] = m.dy * r;
                targetPositions[v0 * 3 + 2] = m.dz * r;
                targetPositions[v1 * 3] = CENTER_X + m.dx * (r + 2);
                targetPositions[v1 * 3 + 1] = m.dy * (r + 2);
                targetPositions[v1 * 3 + 2] = m.dz * (r + 2);
                for (let c = 0; c < 3; c++) {
                    targetColors[v0 * 3 + c] = 0;
                    targetColors[v1 * 3 + c] = 0;
                }
            }
        }

        // â”€â”€â”€ Animation State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let phase = 'intro';
        let animationTime = 0;
        let formationProgress = 0;
        let cameraTargetZ = 55;
        let bloomTarget = 2.2;

        // Start the void formation after a brief delay
        setTimeout(() => {
            phase = 'void-forming';
            setVoidTargets();
        }, 800);

        // â”€â”€â”€ Enter Button Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const enterBtn = document.getElementById('enter-btn');
        const introOverlay = document.getElementById('intro-overlay');
        const portfolioContent = document.getElementById('portfolio-content');

        enterBtn.addEventListener('click', () => {
            if (phase === 'void-forming' || phase === 'void-active') {
                phase = 'dissolve';
                bloomTarget = 0.5;
                cameraTargetZ = 30;
                setDissolveTargets();
                introOverlay.classList.add('hidden');

                setTimeout(() => {
                    portfolioContent.classList.add('visible');
                    document.body.classList.add('scrollable');
                    renderer.domElement.style.transition = 'opacity 2s ease';
                    renderer.domElement.style.opacity = '0';
                    setTimeout(() => {
                        phase = 'portfolio';
                        renderer.domElement.style.display = 'none';
                    }, 2000);
                }, 1500);
            }
        });

        // â”€â”€â”€ Animation Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function animate() {
            requestAnimationFrame(animate);
            if (phase === 'portfolio') return;

            animationTime += 0.016;

            const pos = streaks.geometry.attributes.position.array;
            const col = streaks.geometry.attributes.color.array;

            const lerpSpeed = phase === 'dissolve' ? 0.025 : 0.05;

            // Interpolate all vertex positions and colors toward targets
            for (let i = 0; i < VERTEX_COUNT * 3; i++) {
                pos[i] += (targetPositions[i] - pos[i]) * lerpSpeed;
                col[i] += (targetColors[i] - col[i]) * lerpSpeed;
            }

            // Linear inward flow â€” streaks converge toward center
            if (phase === 'void-forming' || phase === 'void-active') {
                for (let i = 0; i < STREAK_COUNT; i++) {
                    const m = streakMeta[i];
                    const v0 = i * 2;
                    const v1 = i * 2 + 1;
                    const pal = PALETTE[m.colorIdx];

                    const inwardSpeed = m.speed * 0.15;

                    // Move both vertices inward along their radial direction
                    pos[v0 * 3] -= m.dx * inwardSpeed;
                    pos[v0 * 3 + 1] -= m.dy * inwardSpeed;
                    pos[v0 * 3 + 2] -= m.dz * inwardSpeed;
                    pos[v1 * 3] -= m.dx * inwardSpeed;
                    pos[v1 * 3 + 1] -= m.dy * inwardSpeed;
                    pos[v1 * 3 + 2] -= m.dz * inwardSpeed;

                    // Check if inner vertex has reached near the center â€” respawn at outer edge
                    const dx = pos[v0 * 3] - CENTER_X;
                    const dy = pos[v0 * 3 + 1];
                    const dz = pos[v0 * 3 + 2];
                    const distToCenter = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (distToCenter < 3) {
                        // Respawn at outer edge
                        const spawnR = 35 + Math.random() * 40;
                        const streakLen = m.baseLen + Math.random() * 5;
                        pos[v0 * 3] = CENTER_X + m.dx * (spawnR + streakLen);
                        pos[v0 * 3 + 1] = m.dy * (spawnR + streakLen);
                        pos[v0 * 3 + 2] = m.dz * (spawnR + streakLen);
                        pos[v1 * 3] = CENTER_X + m.dx * spawnR;
                        pos[v1 * 3 + 1] = m.dy * spawnR;
                        pos[v1 * 3 + 2] = m.dz * spawnR;

                        // Refresh color with full brightness
                        col[v1 * 3] = pal.r;
                        col[v1 * 3 + 1] = pal.g;
                        col[v1 * 3 + 2] = pal.b;
                        col[v0 * 3] = pal.r * 0.2;
                        col[v0 * 3 + 1] = pal.g * 0.2;
                        col[v0 * 3 + 2] = pal.b * 0.2;
                    }

                    // Brighten streaks as they approach center (white-hot near convergence)
                    if (distToCenter < 15) {
                        const whiteness = 1 - (distToCenter / 15);
                        col[v0 * 3] += (1.0 - col[v0 * 3]) * whiteness * 0.1;
                        col[v0 * 3 + 1] += (1.0 - col[v0 * 3 + 1]) * whiteness * 0.1;
                        col[v0 * 3 + 2] += (1.0 - col[v0 * 3 + 2]) * whiteness * 0.1;
                    }
                }
            }

            streaks.geometry.attributes.position.needsUpdate = true;
            streaks.geometry.attributes.color.needsUpdate = true;

            // Smooth right-to-left horizontal drift (no rotation)
            if (phase !== 'dissolve') {
                streaks.position.x = Math.sin(animationTime * 0.12) * 10 - 5;
            }

            // Camera tracks the offset center point
            camera.position.z += (cameraTargetZ - camera.position.z) * 0.01;
            camera.position.x = CENTER_X * 0.3 + Math.sin(animationTime * 0.15) * 2;
            camera.position.y = Math.cos(animationTime * 0.1) * 1.5;
            camera.lookAt(CENTER_X * 0.5, 0, 0);

            // Bloom intensity
            bloomPass.strength += (bloomTarget - bloomPass.strength) * 0.02;

            // Slight screen shake during formation
            if (phase === 'void-forming') {
                formationProgress += 0.005;
                if (formationProgress > 1) {
                    phase = 'void-active';
                }
                const shake = Math.max(0, 0.3 - formationProgress * 0.3);
                renderer.domElement.style.transform = `translate(${(Math.random() - 0.5) * shake * 20}px, ${(Math.random() - 0.5) * shake * 20}px)`;
            } else {
                renderer.domElement.style.transform = 'translate(0,0)';
            }

            composer.render();
        }
        animate();

        // â”€â”€â”€ Resize Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>